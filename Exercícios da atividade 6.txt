Exercícios da atividade 6 - Passagem de vetores por parâmetro - Páginas 40 a 45

Letra A
1)
#include <iostream>
#define N 2
using namespace std;

void ordenar_argumentos (int a, int b){
    int V [N], i = 0;
    
    if (a >= b){
        V [0] = b;
        V [1] = a;
    } else {
        V [0] = a;
        V [1] = b;
    }
   for (i = 0; i < N; i++){
       cout << V [i] << endl;
   }
}

int main(){
    int valor1 = 0, valor2 = 0;
    cin >> valor1 >> valor2;
    ordenar_argumentos (valor1, valor2);
    return 0;
}

2)
#include <iostream>
using namespace std;

void decomposicao_numero (double x){
    int parte_inteira = 0;
    parte_inteira = x;
    cout << parte_inteira << endl;
    x -= parte_inteira;
    cout << x << endl;
}

int main(){
    double numero = 0;
    cin >> numero;
    decomposicao_numero (numero);
    return 0;
}

Extra: Variação do código com o uso de "casting" (este restringe o valor da variável somente a um tipo que, nesse caso, é um inteiro)
#include <iostream>
using namespace std;

void decomposicao_numero (double x){
    int *int_part = 0;
    *int_part = (int) x;
    cout << &int_part << endl;
    x -= *int_part;
    cout << x << endl;
}

int main(){
    double numero = 0;
    cin >> numero;
    cout << "teste";
    decomposicao_numero (numero);
    return 0;
}


Letra B
A função original é:
bool has_zero(int a[], int n) {
    int i = 0;
    
    for (i = 0; i < n; i++){
        if (a[i] == 0){
            return true;
        } else{
            return false;
        }
    }
}

O erro principal da função é a forma que a estrutura condicional foi feita. Caso o primeiro elemento seja diferente de zero, já há um retorno, desprezando os demais elementos do vetor. 
Para resolver esse problema basta colocar o caso de retornar "falso" fora do laço de repetição.

Um exemplo da função corrigida é:
#include <iostream>
using namespace std;

bool has_zero(int a[], int n) {
    int i = 0;

    for (i = 0; i < n; i++){
        if (a[i] == 0){
            return 1;
        }
    }
    return 0;
}

int main(){
    int a[] = {1, 2, 3, 4, 5}, n = 5;
    cout << has_zero (a, 5);
    return 0;
}

Outra opção é usar uma variável lógica:
#include <iostream>
using namespace std;

bool has_zero(int a[], int n) {
    int i = 0;
    bool x = false;
    
    for (i = 0; i < n; i++){
        if (a[i] == 0){
            x = true;
        }
    }
    return x;
}

int main(){
    int a[] = {1, 2, 3, 4, 5}, n = 5;
    cout << has_zero (a, 5);
    return 0;
}

Cuidado em usar "cout << has_zero". O identificador "has_zero" é de uma função, logo precisa de parâmetros para ser chamada. Tentar usar a instrução sem parâmetros (ou com somente 1 parâmetro) resultará no compilador indicando erro.


Letra C

#include <iostream>
#include <climits>
#define M 3
using namespace std;

void maior_valor (int v [], int N){
    int maior = INT_MIN, i = 0;
    
    for (i = 0; i < N; i++){
        if (v[i] > maior){
            maior = v [i];
        }
    } 
    
    cout << maior << endl;
}

void media_elementos (int t [M]){
    int soma = 0, i = 0;
    
    for (i = 0; i < M; i++){
        soma += t [i];
    }
    
    cout << soma / 3 << endl;
}

void elementos_positivos (int *v, int N){
    int i = 0, positivos = 0;
    
    for (i = 0; i < N; i++){
        if (v[i] > 0){
            positivos++;
        }
    }
    
    cout << positivos << endl;
}

void preencher_vetor (int u [], int N){
    int i = 0;
    
    for (i = 0; i < N; i++){
        cin >> u [i];
    }    
}

void maior_e_menor (int *v, int N, int *ponteiro_maior, int *ponteiro_menor){
    int i = 0, maior = INT_MIN, menor = INT_MAX;
    
    for (i = 0; i < N; i++){
        if (v[i] > maior){
            maior = v [i];
        }
        if (v[i] < menor){
            menor = v [i];
        }
    } 
    *ponteiro_maior = maior;
    *ponteiro_menor = menor;
}

int main(){
    int N = 3, v [N] = {0}, i = 0, t [M] = {1, 2, 3}, u [N] = {0}, maior = 0, menor = 0;
    
    for (i = 0; i < N; i++){
        cin >> v[i];
    }
    
    maior_valor (v, N);
    media_elementos (t);
    elementos_positivos (v, N);
    preencher_vetor (u, N);
    
    for (i = 0; i < N; i++){
        cout << u [i] << " ";
    }
    cout << endl;
    
    maior_e_menor (v, N, &maior, &menor);
    cout << "Maior valor: " << maior << endl;
    cout << "Menor valor: " << menor << endl;
    
    return 0;
} 

Comentários:

1) A impressão do vetor u [N] na função principal após a chamada da função "preencher_vetor" foi possível devido ao fato que toda passagem de vetores por parâmetro ocorre por referência. Tal característica implica que toda modificação feita na função secundária alterará o valor na função principal.

2) Para que a função "maior e menor" modifique as variáveis "maior" e "menor" da função principal é necessário o uso da passagem de parâmetros por referência.


Letra D
1)
Suponha a = 1, b = 2, c = 3. O valor impresso na linha 16 será: 5. Este é consequência de dois processamentos da linha 5, conforme demonstrado nos testes de mesa.

2)
Suponha num = 2000. A resposta da condição da linha 19 será a impressão da linha 22, conforme demonstrado no teste de mesa.

Comentário extra: esse código testa se um número de quatro dígitos é um número de Kaprekar.

3)
Suponha num = 4 e num = 0. O valor impresso na linha 14 com a primeira entrada será "3", contudo a segunda entrada encerra o programa. Esse exemplo pode ser verificado no teste de mesa.

4) O exercício 4 é igual ao primeiro, mas o código está em C++.

5) O exercício 5 é a repetição do 2.

6) O exercício 6 é a repetição do 3.
